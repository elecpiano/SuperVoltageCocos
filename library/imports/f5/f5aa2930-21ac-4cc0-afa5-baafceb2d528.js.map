{"version":3,"sources":["../../../../assets/Script/assets/Script/GameBoardController.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"../../../../assets/Script","sourcesContent":["import CellController from \"./CellController\";\nimport MonsterController from \"./MonsterController\";\nimport TopBarController from \"./TopBarController\";\nimport GiftController from \"./GiftController\";\nimport * as Enums from \"./Enums\";\nimport * as Global from \"./Global\";\nimport ElectricEffect from \"./ElectricEffect/ElectricEffect\";\nimport CongratulationController from \"./CongratulationController\";\nimport BombExplosionController from \"./BombExplosionController\";\n\n\nconst {ccclass, property} = cc._decorator;\n\n@ccclass\nexport default class GameBoardController extends cc.Component {\n\n    //#region Properties\n\n        @property(TopBarController)\n        topBar: TopBarController = null;\n\n        @property(cc.Prefab)\n        cellTemplate: cc.Prefab = null;\n\n        @property(cc.Prefab)\n        MonsterTemplate: cc.Prefab = null;\n\n        @property(cc.Prefab)\n        GiftTemplate: cc.Prefab = null;\n\n        @property(cc.Prefab)\n        CongratulationTemplate: cc.Prefab = null;\n\n        @property(cc.Node)\n        cellMatrixLayer: cc.Node = null;\n\n        @property(cc.Node)\n        MonsterLayer: cc.Node = null;\n\n        @property(cc.Node)\n        giftLayer: cc.Node = null;\n\n        @property(ElectricEffect)\n        electricEffect: ElectricEffect = null;\n\n        @property(cc.Node)\n        EscapeWarning: cc.Node = null;\n\n        @property(BombExplosionController)\n        BombExplosion: BombExplosionController = null;\n\n        gamePaused = false;\n        monsters: Array<MonsterController> = null;\n        CurrentRoundEnemyKill = 0;\n        CurrentlyTouchedCell: CellController = null;\n        usePresets = false;\n        escapedMonsterCount = 0;\n\n    //#endregion\n\n    //#region Lifecycle\n\n    onLoad () {\n        this.initCellMatrix();\n    }\n\n    start () {\n        /// test\n        this.startFilling();   \n    }\n\n    update (dt) {}\n\n    //#endregion\n\n    //#region Game State\n\n    _CurrentGameState: Enums.GameState = Enums.GameState.Idle;\n    get CurrentGameState() {\n        return this._CurrentGameState;\n    }\n    set CurrentGameState(state: Enums.GameState) {\n        this._CurrentGameState = state;\n        this.Debug_CurrentGameState();\n    }\n\n    connectionTrees: CellController[][]  = new Array<Array<CellController>>();\n    droppingCells: Array<CellController> = new Array<CellController>();\n    cellsToFill: Array<CellController> = new Array<CellController>();\n    cellsToRemove: Array<CellController> = new Array<CellController>();\n    movingMonsters: Array<MonsterController> = new Array<MonsterController>();\n    movingGifts: Array<GiftController> = new Array<GiftController>();\n\n    startHint(){\n        for (let cell of this.circuitTree) {\n            cell.ShowHint();\n        }\n        this.scheduleOnce(this.hintSchedule, Global.CIRCUIT_HINT_DURATION);\n        // // audio\n        // Bubble.SEI_ConnectionHint.Stop();\n        // Bubble.SEI_ConnectionHint.Play();\n\n        this.CurrentGameState = Enums.GameState.Hint;\n    }\n\n    abortHint(){\n        this.unschedule(this.hintSchedule);\n        for (let cell of this.circuitTree) {\n            cell.AbortHint();\n        }\n        this.CurrentGameState = Enums.GameState.Idle;\n    }\n\n    hintSchedule(){\n        this.startBurn();\n    }\n\n    startBurn(){\n        this.CurrentGameState = Enums.GameState.Burning;\n        this.setFire(this.circuitTree);\n        this.updateBurn();\n    }\n\n    BurnWithLightning(cell: CellController){\n        this.CurrentGameState = Enums.GameState.Burning;\n        this.setFireWithLightning(cell);\n        this.updateBurn();\n    }\n\n    updateBurn(){\n        this.scheduleOnce(\n            ()=>{\n                this.stopFire();\n                this.tryCongratulateCombo();\n                this.tryBombing();\n            },Global.BURN_DURATION);\n    }\n\n    tryBombing(){\n        console.log(\"xxx - tryBombing\");\n\n        if (this.triggeredBombs.length > 0) {\n            let bomb = this.triggeredBombs.pop();\n            this.startExplosionAt(bomb);\n            this.CurrentGameState = Enums.GameState.Bombing;\n            this.UpdateBombing();\n        }\n        else{\n            this.startDropping();\n        }\n    }\n\n    BombExplode(bomb: GiftController){\n        this.startExplosionAt(bomb);\n        this.CurrentGameState = Enums.GameState.Bombing;\n        this.UpdateBombing();\n    }\n\n    UpdateBombing(){\n        this.scheduleOnce(\n            ()=>{\n                this.stopExplosion();\n                this.tryBombing(); /* a bomb explosion may trigger another bomb, so let's check again */\n            },Global.BOMB_DURATION);\n    }\n\n    dropPlanMatrix: [CellController, number][][] = null;\n    startDropping(){\n        this.droppingCells.splice(0, this.droppingCells.length);\n        this.dropPlanMatrix = new Array();\n        for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++)\n        {\n            let emptyCellCount = 0;\n            let dropPlans:[CellController, number][]= new Array();\n\n            for (let row = 0; row < Global.BOARD_ROW_COUNT; row++)\n            {\n                let cell = this.cellMatrix[row][col];\n                if (cell == null)\n                {\n                    emptyCellCount++;\n                }\n                else if (emptyCellCount > 0)\n                {\n                    let dropPlan: [CellController, number] = [cell, emptyCellCount];\n                    dropPlans.push(dropPlan);\n                    this.droppingCells.push(cell);\n                }\n            }\n            this.dropPlanMatrix.push(dropPlans);\n        }\n\n        this.schedule(()=>{\n            this.dropCell();\n            },Global.CELL_DROP_DELAY,Global.BOARD_ROW_COUNT);\n            \n        this.CurrentGameState = Enums.GameState.Dropping;\n        \n        /* IMPORTANT ! \n        when you burn ONLY the first row of the matrix, there's nothing to drop,\n        and the dropPlanMatrix array has nothing in it, in which case the updateDrop()\n        may never be called. So it's necessary to call updateDrop() method explicitly here. \n        */\n        this.updateDrop();\n    }\n\n    dropCell(){\n        for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++) {\n            let dropPlans = this.dropPlanMatrix[col];\n\n            if (dropPlans.length > 0) {\n                let dropPlan = dropPlans.shift();\n                let cell = dropPlan[0];\n                let dropDistance = dropPlan[1];\n\n                //reset the status of dropping bubble\n                cell.CellState = Enums.CellState.Normal;\n\n                let targetBoardX = cell.Board_X;\n                let targetBoardY = cell.Board_Y - dropDistance;\n                this.cellMatrix[cell.Board_Y][cell.Board_X] = null;\n                this.cellMatrix[targetBoardY][targetBoardX] = cell;\n                cell.Board_Y = targetBoardY;\n                cell.Board_X = targetBoardX;\n\n                cell.MoveToWhereItShouldBe(()=>{\n                    this.droppingCells.splice(this.droppingCells.indexOf(cell),1);\n                    this.updateDrop();\n                });\n\n                \n            }\n        }\n\n    }\n\n    // startDropping_old2(){\n    //     let dropMatrix: number[][] = new Array();\n    //     let dropDelay = 0;\n    //     let thisRowHasDrop = false;\n\n    //     for (let row = 0; row < Global.BOARD_ROW_COUNT; row++) \n    //     {\n    //         let rowData = new Array<number>();\n    //         thisRowHasDrop = false;\n    //         for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++) \n    //         {\n    //             let cell = this.cellMatrix[row][col];\n    //             if (cell == null){\n    //                 if (row == 0) {\n    //                     rowData.push(1);\n    //                 }\n    //                 else{\n    //                     let valueBelow = dropMatrix[row-1][col];\n    //                     rowData.push(valueBelow + 1);\n    //                 }\n    //             }\n    //             else{\n    //                 if (row == 0) {\n    //                     rowData.push(0);\n    //                 }\n    //                 else{\n    //                     let valueBelow = dropMatrix[row-1][col];\n    //                     rowData.push(valueBelow);\n\n    //                     // from second row up, try drop\n    //                     let dropCount = dropMatrix[row-1][col];\n    //                     this.dropCell(cell, dropCount, dropDelay);\n    //                     thisRowHasDrop = true;\n    //                 }\n    //             }\n    //         }\n\n    //         if (thisRowHasDrop) {\n    //             dropDelay++;                \n    //         }\n\n    //         dropMatrix.push(rowData);\n    //     }\n\n    //     this.CurrentGameState = Enums.GameState.Dropping;\n    // }\n\n    // startDropping_old(){\n    //     for (let col = Global.BOARD_COLUMN_COUNT - 1; col >= 0; col--)\n    //     {\n    //         let emptyCellCount = 0;\n    //         for (let row = 0; row < Global.BOARD_ROW_COUNT; row++)\n    //         {\n    //             let cell = this.cellMatrix[row][col];\n    //             if (cell == null)\n    //             {\n    //                 emptyCellCount++;\n    //             }\n    //             else if (emptyCellCount > 0)\n    //             {\n    //                 this.dropCell(cell, emptyCellCount);\n    //             }\n    //         }\n    //     }\n\n    //     this.CurrentGameState = Enums.GameState.Dropping;\n    // }\n\n    // dropCell(cell:CellController, emptyCellCount: number, delay: number){\n    //     //reset the status of dropping bubble\n    //     cell.CellState = Enums.CellState.Normal;\n    //     this.droppingCells.push(cell);\n\n    //     /* The dropping distance equals to the number of empty cells found bellow the cell.\n    //         * In order to understand the relationship between the emptyCellCount and dropping depth,\n    //         * you'd better draw a matrix of cells and do some graphical simulation.*/\n    //     let targetBoardX = cell.Board_X;\n    //     let targetBoardY = cell.Board_Y - emptyCellCount;\n    //     let duration = Global.CELL_DROP_DURATION;\n    //     this.cellMatrix[cell.Board_Y][cell.Board_X] = null;\n    //     this.cellMatrix[targetBoardY][targetBoardX] = cell;\n    //     cell.Board_Y = targetBoardY;\n    //     cell.Board_X = targetBoardX;\n\n    //     cell.scheduleOnce(()=>{\n    //         cell.node.runAction(\n    //             cc.sequence(\n    //                 cc.moveTo(duration,cell.WhereItShouldBe),\n    //                 cc.callFunc(()=>{\n    //                     this.droppingCells.splice(this.droppingCells.indexOf(cell),1);\n    //                     this.updateDrop( );\n    //                 },cell)\n    //             )\n    //         );\n    //     },delay * Global.CELL_DROP_DELAY);\n\n\n    //     if (cell.AttachedMonster != null)\n    //     {\n    //         /*tag bug's dropping status*/\n    //         cell.AttachedMonster.ShouldMoveAround = false;\n    //         cell.scheduleOnce(()=>{\n    //             cell.AttachedMonster.node.runAction(\n    //                 cc.moveTo(duration, cell.WhereItShouldBe)\n    //             );\n    //         },delay * Global.CELL_DROP_DELAY);\n    //     }\n\n    //     if (cell.AttachedGift != null)\n    //     {\n    //         cell.scheduleOnce(()=>{\n    //             cell.AttachedGift.node.runAction(\n    //                 cc.moveTo(duration, cell.WhereItShouldBe)\n    //             );\n    //         },delay * Global.CELL_DROP_DELAY);\n    //     }\n    // }\n\n    updateDrop(){\n        if (this.CurrentGameState == Enums.GameState.Dropping){\n            if (this.droppingCells.length == 0) {\n                this.startFilling();\n            }\n        }\n    }\n\n    startFilling(){\n        this.cellsToFill = this.populateCells();\n        let delayIndex = 0;\n        for (let cell of this.cellsToFill)\n        {\n            // prepare to drop by putting the cell above the starting line\n            cell.GetReadyForShow();\n            \n            cell.scheduleOnce(()=>{\n                cell.node.runAction(\n                    cc.sequence(\n                        cc.moveTo(Global.CELL_DROP_DURATION ,cell.WhereItShouldBe),\n                        cc.callFunc(()=>{\n                            // remove itself from filling list\n                            this.cellsToFill.splice(this.cellsToFill.indexOf(cell),1);\n                            // check if all the filling cells are done\n                            this.updateFill();\n                        },cell)\n                    )\n                );\n            },delayIndex * 0.02);\n\n            delayIndex ++;\n        }\n        this.CurrentGameState = Enums.GameState.Filling;\n    }\n\n    updateFill()\n    {\n        if (this.CurrentGameState == Enums.GameState.Filling)\n        {\n            if (this.cellsToFill.length == 0)\n            {\n                this.UpdateBoard();\n                if (this.circuitTree.length > 0)\n                {\n                    /* setting the GameState to Chain will not halt the game forever,\n                     * since the hint is shown, the Cells on the connection tree will \n                     * be calculating the hint duration and set up a fire spontaneously,\n                     * setting the GameState to Burning. */\n                    this.CurrentGameState = Enums.GameState.Chain;\n                    /* this may also happens unexpectedly:\n                     * When the game quits during the GameState.Burning state, \n                     * all the cell state is saved. And when the game is continued, \n                     * the Burning state causes successively UpdateBurning(...), StartDropping(...),\n                     * UpdateDrop(...), StartFilling(...) and UpdateFill(...). Because there is actually\n                     * no cells to drop and fill, these methods are executed really fast, \n                     * therefore causing this hint detection happen.\n                     * That's why we are setting the GameState to Idle when the game\n                     * is continued. Please refer to CoreLogic.LoadGameData() method. */\n                    if (!this.LightningBurn)\n                    {\n                        this.ChainCount++;\n                    }\n                }\n                else\n                {\n                    this.processMonster();\n                    this.tryCongratulateChain();\n                }\n            }\n        }\n    }\n\n    processMonster(){\n        this.LightningBurn = false;\n        /* move existing bugs around using Lower-First principle */\n        for (let row = 0; row < Global.BOARD_ROW_COUNT; row++)\n        {\n            for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++)\n            {\n                let cell = this.cellMatrix[row][col];\n                if (cell != null && cell.AttachedMonster != null)\n                {\n                    let monster = cell.AttachedMonster;\n                    if (monster.ShouldMoveAround) {\n                        let escaped = monster.MoveAround();\n                        if (!escaped) {\n                            this.movingMonsters.push(monster);                        \n                        }\n                    }\n                    else{\n                        // let it can move for next time\n                        monster.ShouldMoveAround = true;\n                    }\n                }\n            }\n        }\n\n        /* Add new bugs */\n        let newMonsters = this.populateMonsters();\n        for (let monster of newMonsters) {\n            this.movingMonsters.push(monster);\n        }\n\n        for (let monster of this.movingMonsters)\n        {\n            monster.MoveToWhereItShoudBe(\n                ()=>{\n                    this.movingMonsters.splice(this.movingMonsters.indexOf(monster),1);\n                    this.updateMonsterMoving();\n                }\n            );\n        }\n\n        // prepare for next round of movement\n        for (let monster of this.movingMonsters) {\n            monster.AlreadyMovedAround = false;\n        }\n\n        this.CurrentGameState = Enums.GameState.MonsterMoving;\n    }\n\n    updateMonsterMoving(){\n        if (this.CurrentGameState == Enums.GameState.MonsterMoving){\n            if (this.movingMonsters.length == 0) {\n                this.checkGameOver();\n            }\n        }\n    }\n\n    checkGameOver(){\n        if (this.escapedMonsterCount >= 3 ) {\n            // game over\n        }\n        else{\n            this.startGifting();\n        }\n    }\n\n    startGifting(){\n        let newGifts = this.getGifts();\n        if (newGifts.length > 0) {\n            for (let gift of newGifts)\n            {\n                gift.GetReadyForShow();\n                gift.Award(\n                    ()=>{\n                        this.movingGifts.splice(this.movingGifts.indexOf(gift),1);\n                        this.updateGifting();\n                    }\n                );\n            }\n            this.CurrentGameState = Enums.GameState.Gifting; \n        }\n        else{\n            this.goForNextRound();\n        }\n    }\n\n    updateGifting(){\n        if (this.CurrentGameState == Enums.GameState.Gifting){\n            if (this.movingGifts.length == 0) {\n                this.goForNextRound();\n            }\n        }\n    }\n\n    goForNextRound(){\n        this.CurrentGameState = Enums.GameState.Idle; \n    }\n\n\n    //#endregion\n\n    //#region Spark\n\n    @property(cc.ParticleSystem)\n    sparkleT: cc.ParticleSystem = null;\n\n    @property(cc.ParticleSystem)\n    sparkleL: cc.ParticleSystem = null;\n\n    @property(cc.ParticleSystem)\n    sparkleB: cc.ParticleSystem = null;\n\n    @property(cc.ParticleSystem)\n    sparkleR: cc.ParticleSystem = null;\n\n    sparkAt(particle: cc.ParticleSystem, position: cc.Vec2){\n        particle.node.setPosition(position.x, position.y);\n        particle.resetSystem();\n        this.scheduleOnce(()=>particle.stopSystem(), 1);\n    }\n\n    spark(cell: CellController){\n        if (cell.CellState == Enums.CellState.Normal) {\n            return;\n        }\n\n        if (cell.TopConnectedCell != null)\n        {\n            let position = new cc.Vec2(cell.node.position.x, cell.node.position.y + cell.node.height / 2);\n            this.sparkAt(this.sparkleT, position);\n        }\n        if (cell.BottomConnectedCell != null)\n        {\n            let position = new cc.Vec2(cell.node.position.x, cell.node.position.y - cell.node.height / 2);\n            this.sparkAt(this.sparkleB, position);\n        }\n        if (cell.LeftConnectedCell != null || (cell.Board_X == 0 && cell.LeftAntenna))\n        {\n            let position = new cc.Vec2(cell.node.position.x - cell.node.width/2, cell.node.position.y);\n            this.sparkAt(this.sparkleL, position);\n        }\n        if (cell.RightConnectedCell != null || (cell.Board_X == Global.BOARD_COLUMN_COUNT - 1 && cell.RightAntenna))\n        {\n            let position = new cc.Vec2(cell.node.position.x + cell.node.width/2, cell.node.position.y);\n            this.sparkAt(this.sparkleR, position);\n        }\n    }\n\n    //#endregion\n\n    //#region Cell Population\n\n    cellMatrix: CellController[][] = null;\n    freeCells: Array<CellController> = null;\n    leftBorderDetected = false;\n    rightBorderDetected = false;\n\n    initCellMatrix(){\n        // initialize matrix\n        this.cellMatrix = new Array();\n        for (let i = 0; i < Global.BOARD_ROW_COUNT; i++) {\n            let row = new Array(Global.BOARD_COLUMN_COUNT);\n            this.cellMatrix.push(row);\n        }\n\n        // generate cells\n        this.freeCells = new Array<CellController>();\n        for (let i = 0; i < (Global.BOARD_ROW_COUNT * Global.BOARD_COLUMN_COUNT); i++) {\n            let cellNode = cc.instantiate(this.cellTemplate);\n            this.cellMatrixLayer.addChild(cellNode);\n            this.freeCells.push(cellNode.getComponent(CellController));\n            cellNode.setPosition(0,0);\n        }        \n    }\n\n    populateCells() : Array<CellController>{\n        let cellsToAppend: Array<CellController> = null;\n\n        //check for tutorial\n        if (this.usePresets)\n        {\n            cellsToAppend = this.initTutorialCells();\n        }\n        else\n        {\n            cellsToAppend = new Array<CellController>();\n        }\n\n        let cell: CellController = null;\n        let newcell: CellController = null;\n        let connectionTree = new Array<CellController>();\n\n        for (let i = 0; i < Global.BOARD_ROW_COUNT; i++)\n        {\n            for (let j = 0; j < Global.BOARD_COLUMN_COUNT; j++)\n            {\n                if (this.cellMatrix[i][j] != null)\n                {\n                    continue;\n                }\n\n                //get a random cell\n                cell = this.pickUpCell(null, j, i);\n\n                // to test if the cell is acceptable\n                connectionTree.splice(0, connectionTree.length);\n                this.leftBorderDetected = false;\n                this.rightBorderDetected = false;\n                this.getConnectionTree(cell, connectionTree);\n                while (this.leftBorderDetected && this.rightBorderDetected)\n                {\n                    //deny the cell, loop until get a correct one\n                    newcell = this.pickUpCell(cell, j, i);\n                    if (newcell == cell)\n                    {\n                        //can not find any acceptable cell, let it be\n                        break;\n                    }\n                    connectionTree.splice(0, connectionTree.length);\n                    this.leftBorderDetected = false;\n                    this.rightBorderDetected = false;\n                    this.getConnectionTree(newcell, connectionTree);\n                    cell = newcell;\n                }\n\n                cell.Board_X = j;\n                cell.Board_Y = i;\n                this.cellMatrix[i][j] = cell;\n\n                cellsToAppend.push(cell);\n            }\n        }\n\n        /* Set Materials */\n        //CurrentGameLevel.SetMaterialTypes(cellsToAppend);\n\n        return cellsToAppend;\n    }\n\n    /* \n    Get a random bubble by avoiding those denied CellTypes and Rotations. \n    Each time the 'deniedBubble' parameter is set null, this method forgets\n    all the CellTypes and Rotations that has been denied so far and then \n    starts a new round of picking. So be sure to set the 'deniedBubble' parameter\n    to null whenever a new round of picking is intended, and use a while loop \n    right after the method call to ask for a new random pick until you get one.\n    For such examples, please refer to method 'PopulateBubbles()'.\n    */\n    deniedTypes = new Array<Enums.CellType>();\n    deniedRotations = new Array<number>();\n\n    pickUpCell(deniedCell: CellController, board_x: number, board_y:number) : CellController {\n        let cellType = Enums.CellType.I;\n        let rotation = 0;\n        if (deniedCell == null)\n        {\n            //a new round of pick, give it a pure random\n            cellType = this.pickUpCellType();\n            rotation = this.pickUpRotation();\n            this.deniedTypes.splice(0, this.deniedTypes.length);\n            this.deniedRotations.splice(0, this.deniedRotations.length);\n        }\n        else if (this.deniedRotations.length == 4)//all rotations are denied, so let's pick another CellType\n        {\n            if (this.deniedTypes.length == 5)// all CellTypes and rotations have been tested, yet not successful\n            {\n                //can not find any acceptable bubble\n                return deniedCell;\n            }\n            else\n            {\n                this.deniedTypes.push(deniedCell.CellType);\n                cellType = this.pickUpCellType();\n                while (this.deniedTypes.indexOf(cellType) > -1)\n                {\n                    cellType = this.pickUpCellType();\n                }\n\n                this.deniedRotations.splice(0, this.deniedRotations.length);\n                rotation = this.pickUpRotation();\n            }\n        }\n        else\n        {\n            this.deniedRotations.push(deniedCell.RotationQuarterCount);\n            rotation = this.pickUpRotation();\n            while (this.deniedRotations.indexOf(rotation) > -1)\n            {\n                rotation = this.pickUpRotation();\n            }\n        }\n        \n        let cell:CellController = null;\n        if (deniedCell != null) {\n            cell = deniedCell;\n        }\n        else{\n            cell = this.freeCells.pop();\n        } \n\n        cell.initCell(cellType, rotation, board_x, board_y);\n        return cell;\n    }\n    \n    cellTypePool = new Array<Enums.CellType>();\n    initCellTypePool(){\n        // clear the list\n        this.cellTypePool.splice(0, this.cellTypePool.length);\n\n        this.cellTypePool.push(Enums.CellType.Half);\n        this.cellTypePool.push(Enums.CellType.I);\n        this.cellTypePool.push(Enums.CellType.L);\n        this.cellTypePool.push(Enums.CellType.T);\n        this.cellTypePool.push(Enums.CellType.Cross);\n        // this.cellTypePool.push(Enums.CellType.Unknown);\n    }\n\n    pickUpCellType() : Enums.CellType {\n        //clear the pool\n        this.cellTypePool.splice(0, this.cellTypePool.length);\n\n        let crossCount = 0;\n        let tCount = 0;\n        let lCount = 0;\n        let iCount = 0;\n        let halfCount = 0;\n        let unknownCount = 0;\n        for (let rowOfCells of this.cellMatrix)\n        {\n            for (let cell of rowOfCells) {\n                if (cell == null)\n                {\n                    continue;\n                }\n                if (cell.CellType == Enums.CellType.Cross)\n                {\n                    crossCount++;\n                }\n                else if (cell.CellType == Enums.CellType.T)\n                {\n                    tCount++;\n                }else if (cell.CellType == Enums.CellType.L)\n                {\n                    lCount++;\n                }\n                else if (cell.CellType == Enums.CellType.I)\n                {\n                    iCount++;\n                }\n                else if (cell.CellType == Enums.CellType.Half)\n                {\n                    halfCount++;\n                }\n            }\n        }\n\n        if (crossCount < Global.MAX_CROSS_COUNT)\n        {\n            this.cellTypePool.push(Enums.CellType.Cross);\n        }\n\n        if (tCount < Global.MAX_T_COUNT)\n        {\n            this.cellTypePool.push(Enums.CellType.T);\n        }\n\n        if (lCount < Global.MAX_L_COUNT)\n        {\n            this.cellTypePool.push(Enums.CellType.L);\n        }\n\n        if (iCount < Global.MAX_I_COUNT)\n        {\n            this.cellTypePool.push(Enums.CellType.I);\n        }\n\n        if (halfCount < Global.MAX_HALF_COUNT)\n        {\n            this.cellTypePool.push(Enums.CellType.Half);\n        }\n\n        let idx = Math.floor(Math.random() * this.cellTypePool.length);\n        return this.cellTypePool[idx];\n    }\n\n    pickUpRotation() : number {\n        let rotation = Math.floor(Math.random() * 4);\n        return rotation;\n    }\n\n    //#endregion\n\n    //#region Cell Matrix Connection Tree\n\n    circuitTree: Array<CellController> = new Array<CellController>();\n\n    getConnectionTree(cell: CellController, connectionTree: Array<CellController>){\n        connectionTree.push(cell);\n        if (cell.Board_X == 0 && cell.LeftAntenna)\n        {\n            this.leftBorderDetected = true;\n        }\n        else if (cell.Board_X == (Global.BOARD_COLUMN_COUNT - 1) && cell.RightAntenna)\n        {\n            this.rightBorderDetected = true;\n        }\n\n        let connections = cell.GetConnections();\n        if (connections.length > 0)\n        {\n            for (let connectedCell of connections)\n            {\n                if (connectionTree.indexOf(connectedCell) == -1)\n                {\n                    this.getConnectionTree(connectedCell, connectionTree);\n                }\n            }\n        }\n    }\n\n    UpdateBoard(exceptFor : CellController = null) {\n        let tempCellList = new Array<CellController>();\n        if (exceptFor != null)\n        {\n            this.cellMatrix[exceptFor.Board_Y][exceptFor.Board_X] = null;\n            this.abortHint();\n        }\n\n        for (let row of this.cellMatrix) {\n            for (let cell of row){\n                if (cell != null )\n                {\n                    tempCellList.push(cell);\n                }\n            }\n        }\n\n        while (tempCellList.length > 0)\n        {\n            let cell = tempCellList[0];\n            if (cell == null)\n            {\n                continue;\n            }\n            let tree = new Array<CellController>();\n            this.leftBorderDetected = false;\n            this.rightBorderDetected = false;\n            this.getConnectionTree(cell, tree);\n\n            for (let node of tree)\n            {\n                node.SetState(this.leftBorderDetected, this.rightBorderDetected);\n            }\n\n            if (this.leftBorderDetected && this.rightBorderDetected)\n            {\n                this.circuitTree = tree;\n                if (exceptFor == null) {\n                    this.startHint();\n                }\n            }\n\n            for (let node of tree)\n            {\n                tempCellList.splice(tempCellList.indexOf(node),1);\n            }\n        }\n\n        if (exceptFor != null)\n        {\n            this.cellMatrix[exceptFor.Board_Y][exceptFor.Board_X] = exceptFor;\n        }\n    }\n\n    //#endregion\n\n    //#region Burn\n\n    /* LightningBurn property is used to distinguish the manual burn (caused by Lightning) \n    and natural burn (caused by Cell rotation).\n    If it is a Lightning burn, no Combo and Chain is counted. */\n    LightningBurn: boolean = false;\n    CellBurntByLigntning: CellController = null;\n\n    setFire(tree: Array<CellController>){\n        for (let cell of tree)\n        {\n            if (cell.Board_X == 0 && cell.LeftAntenna)//there must be at leat one cell connected to left power (or right power)\n            {\n                /* Initial fire, has no passingInFlame*/\n                cell.Burn(this.electricEffect, Enums.Direction.Left, null);\n                break;\n            }\n        }\n\n        // Audio\n        // (GamePage.Current as GamePage).PlayBurningSoundEffect();\n    }\n\n    setFireWithLightning(cell: CellController){\n        this.LightningBurn = true;\n        this.CellBurntByLigntning = cell;\n        cell.Burn(this.electricEffect, Enums.Direction.Left, null);\n    }\n\n    stopFire(){\n        this.electricEffect.ClearFlows();\n\n        if (this.LightningBurn) {\n            let tree = new Array<CellController>();\n            this.getConnectionTree(this.CellBurntByLigntning, tree);\n            for (let cell of tree) {\n                let toRemove = cell.GetBurnt();\n                if (toRemove) {\n                    this.freeCells.push(cell);\n                    this.cellMatrix[cell.Board_Y][cell.Board_X] = null;\n                    cell.GetReadyForShow();\n                }\n            }\n\n            this.CellBurntByLigntning = null;\n        }\n        else{\n            for (let cell of this.circuitTree) {\n                let toRemove = cell.GetBurnt();\n                if (toRemove) {\n                    this.freeCells.push(cell);\n                    this.cellMatrix[cell.Board_Y][cell.Board_X] = null;\n                    cell.GetReadyForShow();\n                }\n            }\n            this.circuitTree.splice(0, this.circuitTree.length);\n        }\n    }\n\n    //#endregion\n\n    //#region Monster\n\n    Monsters: Array<MonsterController> = new Array<MonsterController>();\n\n    generateMonsters():Array<MonsterController>{\n        let monsters = new Array<MonsterController>();\n\n        // test\n        let monsterNode = cc.instantiate(this.MonsterTemplate);\n        let monster = monsterNode.getComponent(MonsterController);\n        monster.InitMonster(Enums.MonsterType.Small);\n        monsters.push(monster);\n        this.MonsterLayer.addChild(monsterNode);\n\n        return monsters;\n    }\n\n    populateMonsters():Array<MonsterController>{\n        let newMonsters: Array<MonsterController> = new Array<MonsterController>();\n\n        //check for tutorial\n        if (this.usePresets)\n        {\n            newMonsters = this.initTutorialMonsters();\n        }\n        else\n        {\n            /* if it is a Lightning Burn, then check if there is any enemy on the screen.\n             * If there is, then do NOT add new enemy. */\n            if (this.LightningBurn && this.Monsters.length>0)\n            {\n                return;\n            }\n\n            newMonsters = this.generateMonsters();\n\n            //get empty cell in the first row\n            let startingLine = new Array<CellController>();\n            for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++)\n            {\n                let cell = this.cellMatrix[Global.BOARD_ROW_COUNT -1][col];\n                if (cell.AttachedMonster == null)\n                {\n                    startingLine.push(cell);\n                }\n            }\n\n            /* put new bugs into empty cells, until there's no more empty cells,\n             * then give up */\n            for (let monster of newMonsters)\n            {\n                if (startingLine.length <= 0)\n                {\n                    break;\n                }\n\n                let index = Math.floor(Math.random() * startingLine.length);\n                monster.AttachToCell(startingLine[index]);\n                monster.GetReadyForShow();\n                startingLine.splice(index,1);\n            }\n        }\n\n        return newMonsters;\n    }\n\n    removeMonster(monster: MonsterController){\n\n    }\n\n    restoreMonsters(){\n\n    }\n\n    WarnEscape(){\n        this.EscapeWarning.runAction(\n            cc.sequence(\n                cc.fadeIn(Global.ESCAPE_WARNING_DURATION),\n                cc.fadeOut(Global.ESCAPE_WARNING_DURATION),\n                cc.fadeIn(Global.ESCAPE_WARNING_DURATION),\n                cc.fadeOut(Global.ESCAPE_WARNING_DURATION)\n            ));\n    }\n\n    //#endregion\n\n    //#region Gift\n\n    GiftQueue:Array<Enums.GiftType> = new Array<Enums.GiftType>();\n\n    getGifts():Array<GiftController>{\n        let gifts = new Array<GiftController>();\n\n        //check for tutorial\n        if (this.usePresets)\n        {\n            gifts = this.initTutorialGifts();\n        }\n        else\n        {\n            gifts = new Array<GiftController>();\n            for (let giftType of this.GiftQueue)\n            {\n                let row = Math.floor(Math.random() * Global.BOARD_ROW_COUNT);\n                let col = Math.floor(Math.random() * Global.BOARD_COLUMN_COUNT);\n                let emptyCellFound = false;\n\n                while (!emptyCellFound)\n                {\n                    let hasGift = this.cellMatrix[row][col].AttachedGift != null;\n                    let hasMonster = this.cellMatrix[row][col].AttachedMonster != null;\n\n                    if (hasGift || hasMonster)\n                    {\n                        row = Math.floor(Math.random() * Global.BOARD_ROW_COUNT);\n                        col = Math.floor(Math.random() * Global.BOARD_COLUMN_COUNT);\n                    }\n                    else\n                    {\n                        emptyCellFound = true;\n                    }\n                }\n\n                let cellToAttach = this.cellMatrix[row][col];\n                let newGiftNode = cc.instantiate(this.GiftTemplate);\n                this.giftLayer.addChild(newGiftNode);\n                let gift = newGiftNode.getComponent(GiftController);\n                gift.Init(giftType, cellToAttach);\n                gifts.push(gift);\n            }\n            this.GiftQueue.splice(0, this.GiftQueue.length);\n        }\n\n        return gifts;\n    }\n\n    restoreGifts():Array<GiftController>{\n        // foreach (var giftData in gameLevel.SavedGifts)\n        // {\n        //     Gift gift = new Gift(CurrentGamePage, giftData.GiftType, Bubbles[giftData.Board_Y, giftData.Board_X]);\n        //     Gifts.Add(gift);\n        //     CurrentGamePage.Components.Add(gift);\n        //     gift.SetPosition(gift.WhereItShouldBe);\n        // }\n\n        return null;\n    }\n\n    initTutorialGifts():Array<GiftController>{\n        return null;\n    }\n\n    //#endregion\n\n    //#region Chain\n\n    ChainCount: number = 0;\n\n    tryCongratulateChain()\n    {\n        if (this.ChainCount <= 0)\n        {\n            return;\n        }\n\n        /* Queue Bomb Award */\n        for (let index = 0; index < this.ChainCount; index++) {\n            this.GiftQueue.push(Enums.GiftType.Bomb);\n        }\n\n        /* Visual Congratulation */\n        let congratulation = cc.instantiate(this.CongratulationTemplate);\n        let controller = congratulation.getComponent(CongratulationController);\n        controller.ShowAward(this.giftLayer, Enums.CongratulationType.Chain, this.ChainCount);\n\n        this.ChainCount = 0;\n    }\n\n    triggeredBombs: GiftController[] = new Array<GiftController>();\n    QueueTriggeredBomb(bomb: GiftController){\n        this.triggeredBombs.push(bomb);\n    }\n\n    bombedCells: CellController[] = new Array<CellController>();\n    ExplodingBomb: GiftController = null;\n    startExplosionAt(bomb: GiftController) {\n        console.log(\"xxx - startExplosionAt\");\n        this.ExplodingBomb = bomb;\n        let bombCell: CellController = this.ExplodingBomb.attachedCell;\n        this.BombExplosion.Show(bombCell);\n\n        this.bombedCells = new Array<CellController>();\n\n        //target cells on the horizontal\n        for (let col = 0; col < Global.BOARD_COLUMN_COUNT; col++)\n        {\n            var target = this.cellMatrix[bombCell.Board_Y][col];\n            if (target != null)//&& target != bombCell\n            {\n                this.bombedCells.push(target);\n            }\n        }\n\n        //target cells on the vertical\n        for (let row = 0; row < Global.BOARD_ROW_COUNT; row++)\n        {\n            var target = this.cellMatrix[row][bombCell.Board_X];\n            if (target != null && target != bombCell)\n            {\n                this.bombedCells.push(target);\n            }\n        }\n\n        for (let target of this.bombedCells)\n        {\n            target.Bomb();\n        }\n    }\n\n    stopExplosion(){\n        this.BombExplosion.Hide();\n        for (let cell of this.bombedCells) {\n            let toRemove = cell.GetBombed();\n            if (toRemove) {\n                this.freeCells.push(cell);\n                this.cellMatrix[cell.Board_Y][cell.Board_X] = null;\n                cell.GetReadyForShow();\n            }\n        }\n        this.bombedCells.splice(0, this.bombedCells.length);\n    }\n\n    //#endregion\n\n    //#region Combo\n\n    monsterKilledInThisBurn: number = 0;\n\n    CountMonsterKill(){\n        this.monsterKilledInThisBurn ++;\n    }\n\n    tryCongratulateCombo(){\n        console.log(\"xxx - tryCongratulateCombo \"+ this.monsterKilledInThisBurn.toString());\n\n        if (!this.LightningBurn) {\n            /* Queue Combo Award */\n            if (this.monsterKilledInThisBurn <2){\n                this.monsterKilledInThisBurn = 0;\n                return;\n            }\n            else{\n                this.GiftQueue.push(Enums.GiftType.Lightning);\n            }\n\n            /* Visual Congratulation */\n            let congratulation = cc.instantiate(this.CongratulationTemplate);\n            let controller = congratulation.getComponent(CongratulationController);\n            controller.ShowAward(this.giftLayer, Enums.CongratulationType.Combo);\n        }\n\n        /* Reset for next round's counting */\n        this.monsterKilledInThisBurn = 0;\n    }\n\n    //#endregion\n\n    //#region Tutorial\n\n    initTutorialCells() : Array<CellController> {\n        return null;\n    }\n\n    initTutorialMonsters() : Array<MonsterController> {\n        return null;\n    }\n\n    //#endregion\n\n    //#region WX Data API\n\n    // test_SaveData(){\n    //     if (cc.sys.platform === cc.sys.WECHAT_GAME) {\n    //     }\n\n    //     let fs = wx.getFileSystemManager();\n    //     fs.writeFileSync(`${wx.env.USER_DATA_PATH}/hello.txt`, 'hello, world', 'utf8')\n    // }\n\n    // test_LoadData(){\n    //     let fs = wx.getFileSystemManager();\n    //     let data = fs.readFileSync(`${wx.env.USER_DATA_PATH}/hello123.txt`, 'utf8')\n    // }\n\n    //#endregion\n\n    //#region DEBUG\n\n    @property(cc.Label)\n    Debug_Lable: cc.Label = null;\n\n    Debug_CurrentGameState(){\n        this.Debug_Lable.string = this.CurrentGameState.toString();\n    }\n\n    Debug_CellMatrix_Lookup(){\n\n        this.UpdateBoard();\n\n        this.Debug_Lable.string = \"\";\n        for (let i = 0; i < Global.BOARD_ROW_COUNT; i++)\n        {\n            let str = \"\";\n            for (let j = 0; j < Global.BOARD_COLUMN_COUNT; j++)\n            {\n                if (this.cellMatrix[i][j] == null)\n                {\n                    this.Debug_Lable.string += \"[null]\";\n                    continue;\n                }\n                let cell = this.cellMatrix[i][j];\n                str += \"[\"+cell.CellType.toString() + \" \" + cell.RotationQuarterCount.toString()+\"]\";\n            }\n            str = str + \"\\n\" + this.Debug_Lable.string;\n            this.Debug_Lable.string = str;\n        }\n    }\n\n    /*\n\n    debug_r = 0;\n    debug_c = 0;\n\n    Debug_Fill_Cell () {\n\n        let cell: CellController = null;\n        let newcell: CellController = null;\n        this.connectionTree.splice(0, this.connectionTree.length);\n\n        if (this.debug_r >= Global.BOARD_ROW_COUNT) {\n            return;\n        }\n\n        if(this.debug_c == Global.BOARD_COLUMN_COUNT){\n            this.debug_r++;\n            this.debug_c = 0;\n        }\n\n        //get a random cell\n        cell = this.pickUpCell(null, this.debug_c, this.debug_r);\n\n        // to test if the cell is acceptable\n        this.connectionTree.splice(0, this.connectionTree.length);\n        this.leftBorderDetected = false;\n        this.rightBorderDetected = false;\n        this.getConnectionTree(cell);\n        while (this.leftBorderDetected && this.rightBorderDetected)\n        {\n            //deny the cell, loop until get a correct one\n            newcell = this.pickUpCell(cell, this.debug_c, this.debug_r);\n            if (newcell == cell)\n            {\n                //can not find any acceptable cell, let it be\n                break;\n            }\n            this.connectionTree.splice(0, this.connectionTree.length);\n            this.leftBorderDetected = false;\n            this.rightBorderDetected = false;\n            this.getConnectionTree(newcell);\n            cell = newcell;\n        }\n\n        cell.Board_X = this.debug_c;\n        cell.Board_Y = this.debug_r;\n        this.cellMatrix[this.debug_r][this.debug_c] = cell;\n\n        this.debug_c++;\n\n        // prepare to drop by putting the cell above the starting line\n        cell.node.setPosition(cell.Board_X * cell.node.width + Global.BOARD_OFFSET_X, this.node.height + cell.Board_Y * cell.node.height);\n        \n        cell.scheduleOnce(()=>{\n            cell.node.runAction(cc.moveTo(0.3, \n                new cc.Vec2(cell.Board_X * cell.node.width + Global.BOARD_OFFSET_X, cell.Board_Y * cell.node.height + Global.BOARD_OFFSET_Y)));\n        },0.01);\n\n        // this.Debug_CellMatrix_Lookup();\n    }\n\n    */\n\n\n    //#endregion\n\n}\n"]}